## **예외처리(Exception Handling)**

**\[1\] 프로그램 오류**

프로그램을 작성하고 실행시키는 과정에서 크게 두 종류의 에러가 발생할 수 있다.

> 1\. 컴파일 에러 - 컴파일 시에 발생하는 에러(잘못된 문법 기술)  
> 2\. 런타임 에러 - 프로그램 실행 시에 발생하는 에러

런타임 에러는 두 종류로 나누어 볼 수 있다.

> \[런타임 에러\]  
> \- 에러 : 프로그램 코드로 수습될 수 없음(예 : 메모리부족 등)  
> \- 예외 : 프로그램 코드로 수습할 수 있음(예: 배열 인덱스 오류 등)

**\[2\] try ~ catch 구문**

예외처리란 **프로그램 실행 시 발생할 수 있는 예기치 못한 예외의 발생에 대비한 코드를 작성**하는 것.

예외처리의 목적은 **예외의 발생으로 인한 실행 중인 프로그램의 갑작스런 비정상 종료를 막고, 정상적인 실행상태를 유지**할 수 있도록 하는 것이다.

```
	try {
            //예외가 발생할 가능성이 있는 문장들을 넣는다.
        }catch (Exception1 e1){
            //Exception1 이 발생했을 경우, 이를 처리하기 위한 문장을 적는다.
        }catch (Exception2 e2){
            //Exception2 이 발생했을 경우, 이를 처리하기 위한 문장을 적는다.
        }catch (ExceptionN eN){
            //ExceptionN 이 발생했을 경우, 이를 처리하기 위한 문장을 적는다.
        }
```

하나의 try블럭 다음에는 여러 종류의 예외를 처리할 수 있도록 하나 이상의 catch 블럭이 올 수 있으며, 이중 발생한 예외의 종류와 일치하는 단 한 개의 catch 블럭만 수행된다. 발생한 예외의 종류와 일치하는 catch 블럭이 없으면 예외는 처리되지 않는다.

**\[3\] try - catch 문에서의 흐름**

예외가 발생한 경우와 발생하지 않은 경우 문장의 실행순서가 달라진다.

> ☞ try블럭 내에서 예외가 발생한 경우  
> 1\. 발생한 예외와 일치하는 catch블럭이 있는지 확인한다.  
> 2\. 일치하는 catch 블럭을 찾게 되면, 그 catch블럭 내의 문장들을 수행하고 전체 try-catch문을 빠져나가서 그 다음 문장을 계속해서 수행한다. 만일 일치하는 catch 블럭을 찾지 못하면, 예외는 처리되지 못한다.  
>   
> ☞ try블럭 내에서 예외가 발생하지 않은 경우  
> 1\. catch블럭을 거치지 않고 전체 try-catch문을 빠져나가서 수행을 계속한다.

**printStackTrace()와 getMessage()** 

예외가 발생했을 때 생성되는 예외 클래스의 인스턴스에는 발생한 예외에 대한 정보가 담겨져 있으며, getMessage()와 printStackTrace()를 통해서 이 정보들을 얻을 수 있다.

> printStackTrace( ) : 예외발생 당시의 호출 스택(call stack)에 있던 메서드의 정보와 예외 메시지 출력  
> getMessage( ) : 발생한 예외클래스의 인스턴스에 저장된 메시지를 얻을 수 있다.

**멀티 catch 블럭**

JDK 1.7 부터 여러 catch블럭을 '|' 기호를 이용해 하나의 catch블럭으로 합칠수 있게 되었다. 이것이 '멀티 catch 블럭'이다.

```
        try {
            ....
        }catch (Exception1 | Exception2 e){
            e.printStackTrace();
        }
```

**\[4\] 예외 발생시키기**

코딩을 하다보면 자신만의 예외 상황을 만들고 처리해야 하는 경우가 생긴다. 키워드 throw를 사용해서 고의로 예외를 발생 시킬 수 있다.

> **1\. 먼저, 연산자 new를 이용해서 발생시키려는 예외 클래스의 객체를 만든 다음**  
>     Exception e = new Exception("고의로 발생시킴");  
> **2\. 키워드 throw를 이용해서 예외를 발생시킨다.**  
>     throw e;

**\[5\] 메서드 예외 선언하기**

메서드에 예외를 선언하려면. 메서드의 선언부에 키워드 throws를 사용해서 메서드 내에서 발생할 수 있는 예외를 적어주기만 하면 된다. 예외가 여러 개일 경우에는 쉼표(,)로 구분한다.

```
void method() throws Exception1, Exception2, ... ExceptionN {
		//메서드의 내용
}
```

**\[6\] finally 블럭**

finally 블럭은 try- catch 문과 함께 예외 발생의 여부와 관계없이 실행되어야할 코드를 포함시킬 목적으로 사용된다.try-catch 문의 끝에 선택적으로 덧붙여 사용할 수 있으며, try- catch- finally의 순서로 구성된다.

```
        try {
            //예외가 발생할 가능성이 있는 문장들을 넣는다.
        }catch (Exception1 e1){
            //Exception1 이 발생했을 경우, 이를 처리하기 위한 문장을 적는다.
        }finally {
            //예외의 발생여부에 관계없이 항상 수행되어야하는 문장들을 적는다.
        }
```

예외가 발생하는 경우에는 'try → catch → finally'의 순으로 실행되고, 예외가 발생하지 않은 경우에는 'try → finally' 순으로 실행된다.

**\[7\] 자동 자원 반환 - 'try - with - resources'문**

JDK 1.7부터 try - with - resources 문이 새로 추가되었다.주로 입출력에 관련된 클래스를 사용할 때 유용하다.입출력에 사용되는 클래스 중에서는 사용한 후에 꼭 닫아 줘야 하는 것들이 있다. 그래야 사용했던 자원(resources)이 반환되기 때문이다.

**\[8\] 사용자정의 예외 만들기**

기존의 정의된 예외 클래스 외에 필요에 따라 프로그래머가 새로운 예외 클래스를 정의하여 사용할 수 있다. 보통 Exception클래스로부터 상속받는 클래스를 만들지만, 필요에 따라서 알맞은 예외 클래스를 선택할 수 있다.

```
class MyException extends Exception {
    MyException(String msg){    //문자열을 매개변수로 받는 생성자
        super(msg);     // 조상인 Exception클래스의 생성자를 호출한다.
    }
```